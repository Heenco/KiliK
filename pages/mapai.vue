<template>
  <SidebarProvider :default-open="false">
    <div class="h-screen w-full relative flex">
      <!-- Sidebar -->
      <Sidebar variant="sidebar" collapsible="icon" class="border-r pt-16">
        
        <SidebarContent class="pt-0">
          <SidebarGroup class="pt-0">
            <SidebarGroupContent>
              <SidebarMenu>
                <SidebarMenuItem>
                  <SidebarMenuButton @click="openCard('addLayer')">
                    <Plus class="h-4 w-4" />
                    <span>Add Layer</span>
                  </SidebarMenuButton>
                </SidebarMenuItem>
                <SidebarMenuItem>
                  <SidebarMenuButton @click="openCard('layers')">
                    <Layers class="h-4 w-4" />
                    <span>Layers</span>
                  </SidebarMenuButton>
                </SidebarMenuItem>
                <SidebarMenuItem>
                  <SidebarMenuButton @click="openCard('legend')">
                    <Map class="h-4 w-4" />
                    <span>Legend</span>
                  </SidebarMenuButton>
                </SidebarMenuItem>
                <SidebarMenuItem>
                  <SidebarMenuButton @click="openCard('basemap')">
                    <Globe class="h-4 w-4" />
                    <span>Basemap</span>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              </SidebarMenu>
            </SidebarGroupContent>
          </SidebarGroup>
        </SidebarContent>
      </Sidebar>

      <!-- Card Panel -->
      <div v-if="activeCard" class="w-80 bg-background border-r pt-16 shadow-lg">
        <Card class="h-full rounded-none border-0">
          <CardHeader class="border-b">
            <div class="flex items-center justify-between">
              <CardTitle>{{ getCardTitle(activeCard) }}</CardTitle>
              <Button variant="ghost" size="icon" @click="closeCard">
                <X class="h-4 w-4" />
              </Button>
            </div>
          </CardHeader>
          <CardContent class="p-6">
            <div v-if="activeCard === 'addLayer'">
              <p>Add new layers to your map</p>
              <Button class="mt-4">Add Layer</Button>
            </div>
            <div v-else-if="activeCard === 'layers'">
              <div class="flex items-center justify-between mb-4">
                <p class="text-sm text-muted-foreground">Manage your map layers</p>
                <div class="flex items-center gap-2">
                  <span class="text-xs text-muted-foreground">Auto-update</span>
                  <div 
                    class="w-8 h-4 rounded-full cursor-pointer transition-colors"
                    :class="autoUpdateEnabled ? 'bg-blue-500' : 'bg-gray-300'"
                    @click="autoUpdateEnabled ? disableAutoUpdate() : null"
                  >
                    <div 
                      class="w-3 h-3 bg-white rounded-full shadow-sm transition-transform mt-0.5"
                      :class="autoUpdateEnabled ? 'translate-x-4' : 'translate-x-0.5'"
                    ></div>
                  </div>
                </div>
              </div>
              
              <div v-if="autoUpdateEnabled" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <div class="flex items-center gap-2 mb-2">
                  <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                  <span class="text-sm font-medium text-blue-700">Auto-update Active</span>
                </div>
                <p class="text-xs text-blue-600">Query: "{{ lastQuery }}"</p>
                <p class="text-xs text-blue-500 mt-1">Layers update automatically as you move the map</p>
              </div>
              
              <div v-if="mapLayers.length === 0" class="text-center text-muted-foreground py-8">
                <p>No layers added yet</p>
                <p class="text-xs mt-2">Try saying "add schools around Brisbane" in the chat</p>
              </div>
              <div v-else class="space-y-3">
                <div v-for="layer in mapLayers" :key="layer.id" class="flex items-center justify-between p-3 border rounded-lg">
                  <div class="flex-1">
                    <div class="flex items-center gap-2">
                      <div 
                        class="w-4 h-4 rounded-full border-2 border-white shadow-sm" 
                        :style="{ backgroundColor: layer.color }"
                      ></div>
                      <span class="font-medium">{{ layer.name }}</span>
                      <div class="w-2 h-2 rounded-full" :class="layer.visible ? 'bg-green-500' : 'bg-gray-400'"></div>
                      <span v-if="layer.isAutoGenerated" class="text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded">Auto</span>
                    </div>
                    <p class="text-xs text-muted-foreground mt-1">{{ layer.featureCount }} features</p>
                  </div>
                  <div class="flex gap-2">
                    <Button variant="outline" size="sm" @click="toggleLayer(layer.id)">
                      {{ layer.visible ? 'Hide' : 'Show' }}
                    </Button>
                    <Button variant="outline" size="sm" @click="removeLayer(layer.id)" class="text-red-600 hover:text-red-700">
                      Remove
                    </Button>
                  </div>
                </div>
              </div>
            </div>
            <div v-else-if="activeCard === 'legend'">
              <p class="text-sm text-muted-foreground mb-4">Map legend and symbols</p>
              <div v-if="mapLayers.length === 0" class="text-center text-muted-foreground py-8">
                <p>No layers to show in legend</p>
                <p class="text-xs mt-2">Add some layers to see their symbols here</p>
              </div>
              <div v-else class="space-y-3">
                <div v-for="layer in mapLayers.filter(l => l.visible)" :key="layer.id" class="flex items-center gap-3">
                  <div 
                    class="w-4 h-4 rounded-full border-2 border-white shadow-sm" 
                    :style="{ backgroundColor: layer.color }"
                  ></div>
                  <div>
                    <span class="text-sm font-medium">{{ layer.name }}</span>
                    <p class="text-xs text-muted-foreground">{{ layer.featureCount }} locations</p>
                  </div>
                </div>
              </div>
            </div>
            <div v-else-if="activeCard === 'basemap'">
              <p>Change the basemap style</p>
              <div class="grid grid-cols-2 gap-2 mt-4">
                <Button variant="outline" size="sm" @click="changeBasemap('https://demotiles.maplibre.org/style.json')">Default</Button>
                <Button variant="outline" size="sm" @click="changeBasemap('https://tiles.openfreemap.org/styles/liberty')">Liberty</Button>
                <Button variant="outline" size="sm" @click="changeBasemap('https://tiles.openfreemap.org/styles/positron')">Light</Button>
                <Button variant="outline" size="sm" @click="changeBasemap('https://tiles.openfreemap.org/styles/dark-matter')">Dark</Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
      
      <!-- Main content area -->
      <SidebarInset class="flex-1 pt-16">        
        <!-- Basic Mapbox map container -->
        <div id="mapai" class="h-[calc(100vh-4rem)] w-full relative">

      <!-- Chat box overlay using shadcn Nuxt components -->
      <Card class="absolute bottom-10 left-1/2 transform -translate-x-1/2 w-96 z-50">
        <CardHeader>
          <CardTitle>Chat</CardTitle>
        </CardHeader>
        <CardContent>
          <div class="flex flex-col space-y-4">
            <!-- Chat history -->
            <div class="overflow-y-auto max-h-60 border-b border-gray-300 pb-2">
              <div v-for="(message, index) in messages" :key="index" class="text-sm">
                <p :class="{'text-right': message.sender === 'user', 'text-left': message.sender === 'ai'}">
                  <span :class="{'font-bold': message.sender === 'user'}">{{ message.sender === 'user' ? 'You' : 'AI' }}:</span> {{ message.text }}
                </p>
              </div>
            </div>

            <!-- Input area -->
            <div class="flex items-center space-x-2">
              <Input v-model="userInput" placeholder="Type your message..." class="flex-1" />
              <Button @click="sendMessage">Send</Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
      </SidebarInset>
    </div>
  </SidebarProvider>
</template>

<script setup>
import { ref } from 'vue'
import { onMounted, onUnmounted } from 'vue'
import maplibregl from 'maplibre-gl'
import { Plus, Layers, Map, Globe, X } from 'lucide-vue-next'
import Card from '@/components/ui/card/Card.vue'
import CardHeader from '@/components/ui/card/CardHeader.vue'
import CardTitle from '@/components/ui/card/CardTitle.vue'
import CardContent from '@/components/ui/card/CardContent.vue'
import Input from '@/components/ui/input/Input.vue'
import Button from '@/components/ui/button/Button.vue'
import { 
  Sidebar, 
  SidebarProvider, 
  SidebarContent, 
  SidebarHeader, 
  SidebarInset,
  SidebarGroup,
  SidebarGroupLabel,
  SidebarGroupContent,
  SidebarMenu,
  SidebarMenuItem,
  SidebarMenuButton,
  SidebarTrigger
} from '@/components/ui/sidebar'
import { useOpenAI } from '~/composables/useOpenAI';
import { useOverpass } from '~/composables/useOverpass';

let map = null

onMounted(async () => {
  // Initialize MapLibre map (no API key required)
  map = new maplibregl.Map({
    container: 'mapai',
    style: 'https://tiles.openfreemap.org/styles/positron', // Light theme for first load
    center: [153.0251, -27.4698], // Brisbane coordinates
    zoom: 10
  });

  // Add navigation controls after map loads
  map.on('load', () => {
    map.addControl(new maplibregl.NavigationControl(), 'top-right');
  });
});

onUnmounted(() => {
  // Clean up auto-update
  disableAutoUpdate()
  
  if (map) {
    map.remove()
  }
})

// Chat box logic
const messages = ref([])
const userInput = ref('')

// Card panel logic
const activeCard = ref(null)
// Map layers management
const mapLayers = ref([])
// Auto-update settings
const autoUpdateEnabled = ref(false)
const lastQuery = ref('')
const updateTimeout = ref(null)

const openCard = (cardType) => {
  activeCard.value = cardType
}

const closeCard = () => {
  activeCard.value = null
}

const getCardTitle = (cardType) => {
  const titles = {
    addLayer: 'Add Layer',
    layers: 'Layers',
    legend: 'Legend',
    basemap: 'Basemap'
  }
  return titles[cardType] || ''
}

const changeBasemap = (styleUrl) => {
  if (map) {
    map.setStyle(styleUrl)
  }
}

const toggleLayer = (layerId) => {
  const layer = mapLayers.value.find(l => l.id === layerId)
  if (layer && map) {
    layer.visible = !layer.visible
    if (layer.visible) {
      // Show the layer
      map.setLayoutProperty(layer.layerId, 'visibility', 'visible')
    } else {
      // Hide the layer
      map.setLayoutProperty(layer.layerId, 'visibility', 'none')
    }
  }
}

const removeLayer = (layerId) => {
  const layerIndex = mapLayers.value.findIndex(l => l.id === layerId)
  if (layerIndex !== -1) {
    const layer = mapLayers.value[layerIndex]
    
    // Remove click and hover event listeners
    map.off('click', layer.layerId)
    map.off('mouseenter', layer.layerId)
    map.off('mouseleave', layer.layerId)
    
    // Remove layer and source from map
    if (map.getLayer(layer.layerId)) {
      map.removeLayer(layer.layerId)
    }
    if (map.getSource(layer.sourceId)) {
      map.removeSource(layer.sourceId)
    }
    
    // Remove from layers list
    mapLayers.value.splice(layerIndex, 1)
  }
}

const extractLayerName = (userRequest) => {
  const request = userRequest.toLowerCase()
  
  // Common patterns to extract meaningful layer names
  if (request.includes('school')) return 'Schools'
  if (request.includes('hospital')) return 'Hospitals'
  if (request.includes('restaurant') || request.includes('food')) return 'Restaurants'
  if (request.includes('park')) return 'Parks'
  if (request.includes('bank')) return 'Banks'
  if (request.includes('shop') || request.includes('store')) return 'Shops'
  if (request.includes('hotel')) return 'Hotels'
  if (request.includes('gas') || request.includes('fuel')) return 'Gas Stations'
  if (request.includes('pharmacy')) return 'Pharmacies'
  if (request.includes('cafe')) return 'Cafes'
  if (request.includes('atm')) return 'ATMs'
  if (request.includes('church') || request.includes('temple') || request.includes('mosque')) return 'Religious Places'
  if (request.includes('library')) return 'Libraries'
  if (request.includes('gym') || request.includes('fitness')) return 'Gyms'
  
  // Generic fallback
  return 'Custom Layer'
}

const updateLayersForCurrentView = async () => {
  if (!map || !autoUpdateEnabled.value || !lastQuery.value) return

  const bounds = map.getBounds()
  const center = map.getCenter()
  
  // Extract layer type from the original query
  const layerName = extractLayerName(lastQuery.value)
  
  console.log('Auto-updating layers for current view - Layer type:', layerName)
  
  // Clear existing auto-generated layers (keep only manually added ones)
  const autoLayers = mapLayers.value.filter(layer => layer.isAutoGenerated)
  autoLayers.forEach(layer => removeLayer(layer.id))
  
  // Create Overpass query directly based on layer type and current bounds
  const overpassQuery = createOverpassQuery(layerName, bounds)
  
  if (!overpassQuery) {
    console.error('Could not create Overpass query for layer type:', layerName)
    return
  }
  
  console.log('Direct Overpass query:', overpassQuery)
  
  // Query Overpass API directly
  const features = await useOverpass(overpassQuery)
  
  if (features && features.length > 0) {
    console.log('Auto-update: Features found:', features.length)
    
    // Add features to map
    await addFeaturesToMapDirect(features, layerName, true)
  } else {
    console.log('Auto-update: No features found in current view')
  }
}

const createOverpassQuery = (layerName, bounds) => {
  const sw = bounds.getSouthWest()
  const ne = bounds.getNorthEast()
  const bbox = `${sw.lat},${sw.lng},${ne.lat},${ne.lng}`
  
  // Map layer names to Overpass amenity/shop types
  const queryMap = {
    'Schools': `[out:json][timeout:25];
(
  node["amenity"="school"](${bbox});
  way["amenity"="school"](${bbox});
  relation["amenity"="school"](${bbox});
);
out geom;`,
    'Hospitals': `[out:json][timeout:25];
(
  node["amenity"="hospital"](${bbox});
  way["amenity"="hospital"](${bbox});
  relation["amenity"="hospital"](${bbox});
);
out geom;`,
    'Restaurants': `[out:json][timeout:25];
(
  node["amenity"="restaurant"](${bbox});
  way["amenity"="restaurant"](${bbox});
  relation["amenity"="restaurant"](${bbox});
);
out geom;`,
    'Parks': `[out:json][timeout:25];
(
  node["leisure"="park"](${bbox});
  way["leisure"="park"](${bbox});
  relation["leisure"="park"](${bbox});
);
out geom;`,
    'Banks': `[out:json][timeout:25];
(
  node["amenity"="bank"](${bbox});
  way["amenity"="bank"](${bbox});
  relation["amenity"="bank"](${bbox});
);
out geom;`,
    'Shops': `[out:json][timeout:25];
(
  node["shop"](${bbox});
  way["shop"](${bbox});
  relation["shop"](${bbox});
);
out geom;`,
    'Hotels': `[out:json][timeout:25];
(
  node["tourism"="hotel"](${bbox});
  way["tourism"="hotel"](${bbox});
  relation["tourism"="hotel"](${bbox});
);
out geom;`,
    'Gas Stations': `[out:json][timeout:25];
(
  node["amenity"="fuel"](${bbox});
  way["amenity"="fuel"](${bbox});
  relation["amenity"="fuel"](${bbox});
);
out geom;`,
    'Pharmacies': `[out:json][timeout:25];
(
  node["amenity"="pharmacy"](${bbox});
  way["amenity"="pharmacy"](${bbox});
  relation["amenity"="pharmacy"](${bbox});
);
out geom;`,
    'Cafes': `[out:json][timeout:25];
(
  node["amenity"="cafe"](${bbox});
  way["amenity"="cafe"](${bbox});
  relation["amenity"="cafe"](${bbox});
);
out geom;`,
    'ATMs': `[out:json][timeout:25];
(
  node["amenity"="atm"](${bbox});
  way["amenity"="atm"](${bbox});
  relation["amenity"="atm"](${bbox});
);
out geom;`,
    'Religious Places': `[out:json][timeout:25];
(
  node["amenity"~"^(place_of_worship)$"](${bbox});
  way["amenity"~"^(place_of_worship)$"](${bbox});
  relation["amenity"~"^(place_of_worship)$"](${bbox});
);
out geom;`,
    'Libraries': `[out:json][timeout:25];
(
  node["amenity"="library"](${bbox});
  way["amenity"="library"](${bbox});
  relation["amenity"="library"](${bbox});
);
out geom;`,
    'Gyms': `[out:json][timeout:25];
(
  node["leisure"="fitness_centre"](${bbox});
  way["leisure"="fitness_centre"](${bbox});
  relation["leisure"="fitness_centre"](${bbox});
);
out geom;`
  }
  
  return queryMap[layerName] || null
}

const addFeaturesToMapDirect = async (features, layerName, isAutoGenerated = false) => {
  if (!map || !features || features.length === 0) return

  const layerId = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  const layerColor = getLayerColor(layerName)
  
  // Create GeoJSON source from features
  const geojsonData = {
    type: 'FeatureCollection',
    features: features.map(feature => ({
      type: 'Feature',
      geometry: feature.geometry,
      properties: {
        ...feature.properties,
        layerId: layerId,
        layerName: layerName,
        color: layerColor
      }
    }))
  }

  // Add source to map
  map.addSource(layerId, {
    type: 'geojson',
    data: geojsonData
  });

  // Add circle layer for the points
  map.addLayer({
    id: `${layerId}-circles`,
    type: 'circle',
    source: layerId,
    paint: {
      'circle-radius': 8,
      'circle-color': layerColor,
      'circle-stroke-color': '#ffffff',
      'circle-stroke-width': 3,
      'circle-opacity': 1,
      'circle-stroke-opacity': 1
    }
  });

  // Add click event for popups
  map.on('click', `${layerId}-circles`, (e) => {
    const coordinates = e.features[0].geometry.coordinates.slice();
    const properties = e.features[0].properties;
    
    while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
      coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
    }

    new maplibregl.Popup()
      .setLngLat(coordinates)
      .setHTML(`<strong>${properties.name || layerName}</strong>`)
      .addTo(map);
  });

  // Change cursor on hover
  map.on('mouseenter', `${layerId}-circles`, () => {
    map.getCanvas().style.cursor = 'pointer';
  });

  map.on('mouseleave', `${layerId}-circles`, () => {
    map.getCanvas().style.cursor = '';
  });

  // Add new layer to the layers list
  mapLayers.value.push({
    id: layerId,
    name: layerName,
    visible: true,
    sourceId: layerId,
    layerId: `${layerId}-circles`,
    featureCount: features.length,
    color: layerColor,
    isAutoGenerated: isAutoGenerated
  })

  return `Added ${features.length} ${layerName.toLowerCase()} to the map as a new GeoJSON layer.`
}

const enableAutoUpdate = (query) => {
  autoUpdateEnabled.value = true
  lastQuery.value = query
  
  // Add event listeners for map movement
  map.on('moveend', () => {
    // Debounce the update to avoid too many API calls
    if (updateTimeout.value) {
      clearTimeout(updateTimeout.value)
    }
    
    updateTimeout.value = setTimeout(() => {
      updateLayersForCurrentView()
    }, 1000) // Wait 1 second after movement stops
  })
  
  // Also update on zoom end
  map.on('zoomend', () => {
    if (updateTimeout.value) {
      clearTimeout(updateTimeout.value)
    }
    
    updateTimeout.value = setTimeout(() => {
      updateLayersForCurrentView()
    }, 500) // Shorter delay for zoom
  })
}

const disableAutoUpdate = () => {
  autoUpdateEnabled.value = false
  lastQuery.value = ''
  
  // Remove event listeners
  map.off('moveend')
  map.off('zoomend')
  
  if (updateTimeout.value) {
    clearTimeout(updateTimeout.value)
  }
  
  // Remove auto-generated layers
  const autoLayers = mapLayers.value.filter(layer => layer.isAutoGenerated)
  autoLayers.forEach(layer => removeLayer(layer.id))
}

const getLayerColor = (layerName) => {
  const colorMap = {
    'Schools': '#3B82F6',      // Blue
    'Hospitals': '#EF4444',    // Red
    'Restaurants': '#F59E0B',  // Orange
    'Parks': '#10B981',        // Green
    'Banks': '#8B5CF6',        // Purple
    'Shops': '#EC4899',        // Pink
    'Hotels': '#14B8A6',       // Teal
    'Gas Stations': '#F97316', // Orange-red
    'Pharmacies': '#06B6D4',   // Cyan
    'Cafes': '#84CC16',        // Lime
    'ATMs': '#6366F1',         // Indigo
    'Religious Places': '#A855F7', // Violet
    'Libraries': '#0EA5E9',    // Sky blue
    'Gyms': '#F43F5E',         // Rose
    'Custom Layer': '#6B7280'  // Gray
  }
  
  return colorMap[layerName] || '#6B7280'
}

const addFeaturesToMap = async (userRequest, isAutoGenerated = false) => {
  if (!map) return;

  // Generate Overpass query using OpenAI
  const aiResponse = await useOpenAI(userRequest);
  const overpassQuery = aiResponse.overpassQuery;

  console.log('Query generated by AI:', overpassQuery); // Debug the query

  if (!overpassQuery) {
    console.error('Invalid query generated by AI');
    return;
  }

  // Query Overpass API with the generated query
  const features = await useOverpass(overpassQuery);

  if (features && features.length > 0) {
    console.log('Features added to the map:', features);

    // Extract layer name from user request
    const layerName = extractLayerName(userRequest)
    const layerId = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    const layerColor = getLayerColor(layerName)
    
    // Create GeoJSON source from features
    const geojsonData = {
      type: 'FeatureCollection',
      features: features.map(feature => ({
        type: 'Feature',
        geometry: feature.geometry,
        properties: {
          ...feature.properties,
          layerId: layerId,
          layerName: layerName,
          color: layerColor
        }
      }))
    }

    // Add source to map
    map.addSource(layerId, {
      type: 'geojson',
      data: geojsonData
    });

    // Add circle layer for the points
    map.addLayer({
      id: `${layerId}-circles`,
      type: 'circle',
      source: layerId,
      paint: {
        'circle-radius': 8,
        'circle-color': layerColor,
        'circle-stroke-color': '#ffffff',
        'circle-stroke-width': 3,
        'circle-opacity': 1,
        'circle-stroke-opacity': 1
      }
    });

    // Add click event for popups
    map.on('click', `${layerId}-circles`, (e) => {
      const coordinates = e.features[0].geometry.coordinates.slice();
      const properties = e.features[0].properties;
      
      // Ensure that if the map is zoomed out such that multiple
      // copies of the feature are visible, the popup appears
      // over the copy being pointed to.
      while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
        coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
      }

      new maplibregl.Popup()
        .setLngLat(coordinates)
        .setHTML(`<strong>${properties.name || layerName}</strong>`)
        .addTo(map);
    });

    // Change cursor on hover
    map.on('mouseenter', `${layerId}-circles`, () => {
      map.getCanvas().style.cursor = 'pointer';
    });

    map.on('mouseleave', `${layerId}-circles`, () => {
      map.getCanvas().style.cursor = '';
    });

    // Add new layer to the layers list
    mapLayers.value.push({
      id: layerId,
      name: layerName,
      visible: true,
      sourceId: layerId,
      layerId: `${layerId}-circles`,
      featureCount: features.length,
      color: layerColor,
      isAutoGenerated: isAutoGenerated
    })

    return `Added ${features.length} ${layerName.toLowerCase()} to the map as a new GeoJSON layer.`
  } else {
    console.error('No features returned from Overpass API');
    return 'No features found for your request.'
  }
};

const sendMessage = async () => {
  if (userInput.value.trim() === '') return;

  // Add user message to chat history
  messages.value.push({ sender: 'user', text: userInput.value });

  if (userInput.value.toLowerCase().includes('add')) {
    const result = await addFeaturesToMap(userInput.value, false);
    messages.value.push({ sender: 'ai', text: result || 'Features have been added to the map.' });
    
    // Enable auto-update for this query type
    enableAutoUpdate(userInput.value);
    messages.value.push({ 
      sender: 'ai', 
      text: 'Auto-update enabled! Layers will now update automatically as you move the map.' 
    });
  } else {
    // Get AI response from OpenAI
    const aiResponse = await useOpenAI(userInput.value);
    messages.value.push({ sender: 'ai', text: aiResponse });
  }

  // Clear input field
  userInput.value = '';
};
</script>

<style>
@import 'maplibre-gl/dist/maplibre-gl.css';

/* Override any conflicting styles with !important */
#mapai .maplibregl-ctrl-top-right {
  top: 80px !important;
  right: 10px !important;
  position: absolute !important;
  transform: none !important;
  margin: 0 !important;
}

#mapai .maplibregl-ctrl-bottom-right {
  bottom: 0 !important;
  right: 0 !important;
  position: absolute !important;
  transform: none !important;
  margin: 0 !important;
}

/* Map container styling */
#mapai {
  background-color: #1a1a1a;
  position: relative !important;
  width: 100% !important;
  height: 100% !important;
}

/* Reset any transforms or positioning that might interfere */
#mapai .maplibregl-ctrl {
  margin: 0 !important;
  position: relative !important;
  transform: none !important;
  top: auto !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
}

/* Apply the preferred font (Arial or Helvetica) */
#mapai .text-sm {
  font-family: 'Arial', 'Helvetica', sans-serif;
  font-size: 0.875rem;
  line-height: 1.25rem;
}

#mapai .font-bold {
  font-weight: 700;
}

/* Auto-update toggle styling */
.translate-x-4 {
  transform: translateX(1rem);
}

.translate-x-0\.5 {
  transform: translateX(0.125rem);
}
</style>
